# app.py
# ChemWeaver backend: RDKit-powered SMILES â†’ 3D SDF and Gaussian .gjf
#
# Requirements:
#   pip install flask flask-cors rdkit-pypi
# Run:
#   python app.py    (serves at http://127.0.0.1:5000)

from flask import Flask, request, jsonify, Response
from flask_cors import CORS
from rdkit import Chem
from rdkit.Chem import AllChem
from rdkit.Chem.rdchem import BondType

app = Flask(__name__)
CORS(app)

def gaussian_bond_order(bond) -> float:
    bt = bond.GetBondType()
    if bt == BondType.SINGLE:   return 1.0
    if bt == BondType.DOUBLE:   return 2.0
    if bt == BondType.TRIPLE:   return 3.0
    if bt == BondType.AROMATIC or bond.GetIsAromatic():
        return 1.5
    return 1.0

def smiles_to_rdkit_with_H(smiles: str):
    mol = Chem.MolFromSmiles(smiles)
    if mol is None:
        raise ValueError("Invalid SMILES")
    mol = Chem.AddHs(mol)
    return mol

def embed_3d_inplace(mol):
    # ETKDG + quick UFF relaxation
    AllChem.EmbedMolecule(mol, AllChem.ETKDG())
    AllChem.UFFOptimizeMolecule(mol)
    return mol

def mol_to_sdf_text(mol) -> str:
    # Make a temp writer to string
    # (RDKit's SDWriter expects a file-like; use in-memory)
    from io import StringIO
    sio = StringIO()
    w = Chem.SDWriter(sio)
    w.write(mol)
    w.flush()
    return sio.getvalue()

def build_connectivity_lines(mol) -> str:
    # Symmetric neighbor listing with true bond orders
    lines = []
    nat = mol.GetNumAtoms()
    nbrs = {i: [] for i in range(nat)}
    for b in mol.GetBonds():
        i = b.GetBeginAtomIdx()
        j = b.GetEndAtomIdx()
        order = gaussian_bond_order(b)
        nbrs[i].append((j, order))
        nbrs[j].append((i, order))

    for i in range(nat):
        if not nbrs[i]:
            lines.append(f" {i+1}")
            continue
        parts = [f" {i+1}"]
        for j, o in sorted(nbrs[i], key=lambda t: t[0]):
            parts.append(f"{j+1} {o:.1f}")
        lines.append(" ".join(parts))
    return "\n".join(lines) + "\n"

def format_gaussian(mol, title: str, header: str, include_conn: bool = True) -> str:
    # Coordinates
    conf = mol.GetConformer()
    coords = []
    for a in mol.GetAtoms():
        idx = a.GetIdx()
        pos = conf.GetAtomPosition(idx)
        coords.append((a.GetSymbol(), pos.x, pos.y, pos.z))

    # Build text
    out = []
    if header:
        out.append(header.rstrip() + "\n\n")
    out.append(f"{title}\n\n")
    out.append("0 1\n")
    for (sym, x, y, z) in coords:
        out.append(f" {sym:<2} {x:>10.6f} {y:>10.6f} {z:>10.6f}\n")
    if include_conn:
        out.append("\n")
        out.append(build_connectivity_lines(mol))
    return "".join(out)

@app.route("/api/smiles2sdf", methods=["POST"])
def api_smiles2sdf():
    """
    Input JSON: {"smiles": "..."}
    Output: SDF text (3D, hydrogens added)
    """
    data = request.get_json(force=True)
    smiles = (data.get("smiles") or "").strip()
    if not smiles:
        return jsonify({"error": "Missing 'smiles'"}), 400
    try:
        mol = smiles_to_rdkit_with_H(smiles)
        embed_3d_inplace(mol)
        sdf = mol_to_sdf_text(mol)
        return Response(sdf, mimetype="chemical/x-mdl-sdfile")
    except Exception as e:
        return jsonify({"error": str(e)}), 400

@app.route("/api/gjf", methods=["POST"])
def api_gjf():
    """
    Input JSON:
      {
        "smiles": "...",
        "header": "%chk=<name>.chk\n# opt freq B3LYP/6-31G(d) geom=connectivity",
        "title":  "C6H6 generated by ChemWeaver",
        "include_connectivity": true
      }
    Output: plain text .gjf
    """
    data = request.get_json(force=True)
    smiles = (data.get("smiles") or "").strip()
    if not smiles:
        return jsonify({"error": "Missing 'smiles'"}), 400

    header = data.get("header", "").strip()
    title  = data.get("title", smiles)
    include_conn = bool(data.get("include_connectivity", True))

    try:
        mol = smiles_to_rdkit_with_H(smiles)
        embed_3d_inplace(mol)
        gjf = format_gaussian(mol, title, header, include_conn)
        return Response(gjf, mimetype="text/plain")
    except Exception as e:
        return jsonify({"error": str(e)}), 400

@app.route("/")
def ok():
    return "ChemWeaver backend OK"

if __name__ == "__main__":
    app.run(debug=True)
